# Linux设备驱动中的并发控制
    并发与竞态的概念及发生的场合
    编译乱序、执行乱序的问题，内存屏障

    <<Linux设备驱动开发详解：基于最新的Linux 4.0内核>>


### 并发与竞态
    并发（Concurrency）指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源
    （硬件资源和软件上的全局变量、静态变量等）的访问则很容易导致竞态（Race Conditions）；
    并发大量存在于设备驱动中，只要并发的多个执行单元存在对共享资源的访问，竞态就可能发生；

    在Linux内核中，主要的竞态发生于如下几种情况：

    1. 对称多处理器（SMP）的多个CPU
    SMP是一种紧耦合、共享存储的系统模型，它的特点是多个CPU使用共同的系统总线，因此可访问共同的外设和存储器；

    2. 单CPU内进程与抢占它的进程
    Linux 2.6以后的内核支持内核抢占调度，一个进程在内核执行的时候，可能耗完了自己的时间片（timeslice），
    也可能被另一个高优先级进程打断，进程与抢占它的进程访问共享资源的情况类似于SMP的多个CPU；

    3. 中断（硬中断、软中断、Tasklet、底半部）与进程之间
    中断可以打断正在执行的进程，如果中断服务程序访问进程正在访问的资源，则竞态也会发生；
    此外，中断也可能被新的更高优先级的中断打断，因此多个中断之间本身也可能引起并发而导致竞态；
    但是Linux 2.6.35之后，就取消了中断的嵌套；老版本的内核可以在申请中断时，设置标记IRQ_DISABLED
    以避免中断嵌套，由于新内核直接就默认不嵌套中断，这个标记就无用了；

    上述并发的发生除了SMP是真正的并行以外，其它的都是单核上的“宏观并行，微观串行”，但其引发的实质问题和SMP相似；
    解决竞态问题的途径是保证对共享资源的互斥访问，
    所谓互斥访问是指一个执行单元在访问共享资源的时候，其它的执行单元被禁止访问；

    访问共享资源的代码区域称为临界区（Critical Sections），临界区需要被以某种互斥机制加以保护；
    中断屏蔽、原子操作、自旋锁、信号量、互斥体等是Linux设备驱动中可采用的互斥途径；


### 编译乱序与执行乱序
    理解Linux内核的锁机制，还需要理解编译器和处理器的特点；

    现代的高性能编译器在目标码优化上都具备对指令进行乱序优化的能力；编译器可以对访存的指令进行乱序，
    减少逻辑上不必要的访存，以及尽量提高Cache命中率和CPU的Load/Store单元的工作效率；
    因此在打开编译器优化以后，看到生成的汇编码并没有按照代码的逻辑顺序，这是正常；

    解决编译乱序问题，需要通过 barrier()编译屏障进行，可以阻挡编译器的优化；
    #define barrier()   __asm__ __volatile__("": : :"memory")

    关于解决编译乱序的问题，C语言 volatile 关键字的作用较弱，它更多的只是避免内存访问行为的合并，
    对C编译器而言，volatile是暗示除了当前的执行线索以外，其它的执行线索也可能改变内存，所以它的含义是“易变的”；

    编译乱序是编译器的行为，而执行乱序则是处理器运行时的行为；
    高级的CPU可以根据自己缓存的组织特性，将访存指令重新排序执行；
    连续地址的访问可能会先执行，因为这样缓存命中率高；有的还允许访存的非阻塞，即如果前面一条访存指令因为缓存
    不命中，造成长延时的存储访问时，后面的访存指令可以先执行，以便从缓存中取数；
    因此，即使是从汇编上看顺序正确的指令，其执行的顺序也是不可预知的；

    对于大多数体系结构而言，尽管每个CPU都是乱序执行，但是这一乱序对于单核的程序执行是不可见的，因为每个CPU
    在碰到依赖点（后面的指令依赖于前面指令的执行结果）的时候会等待，所以程序员可能感觉不到这个乱序过程；
    但是这个依赖点等待的过程，在SMP处理器里面对于其它核是不可见的；

    处理器为了解决多核间一个核的内存行为对另一个核可见的问题，引入了一些内存屏障的指令；
    譬如，ARM处理器的屏障指令包括：
    DMB（数据内存屏障）：在DMB之后的显式内存访问执行前，保证所有在DMB指令之前的内存访问完成；
    DSB（数据同步屏障）：等待所有在DSB指令之前的指令完成（位于此指令前的所有显式内存访问均完成，位于此指令前的所
                      有缓存、跳转预测和TLB维护操作全部完成）；
    ISB（指令同步屏障）：Flush流水线，使得所有ISB之后执行的指令都是从缓存或内存中获得的；

    Linux内核的自旋锁、互斥体等互斥逻辑，需要用到上述指令：
    在请求获得锁时，调用屏障指令；在解锁时，也需要调用屏障指令；

    前面提到每个CPU都是乱序执行，但是单个CPU在碰到依赖点的时候会等待，所以执行乱序对单核不一定可见；
    但是，当程序在访问外设的寄存器时，这些寄存器的访问顺序在CPU的逻辑上构不成依赖关系，
    但是从外设的逻辑角度来讲，可能需要固定的寄存器读写顺序，这个也需要使用CPU的内存屏障指令；

    在Linux内核中，定义了读写屏障 mb()、读屏障 rmb()、写屏障 wmb()、
    以及作用于寄存器读写的 __iormb()、__iowmb() 这样的屏障API；
    读写寄存器的 readl_relaxed() 和 readl()、writel_relaxed() 和 writel() API的区别
    就体现在有无屏障方面；

    #define readb(c)        (( u8  __v = readb_relaxed(c); __iormb(); __v; ))
    #define readw(c)        (( u16 __v = readw_relaxed(c); __iormb(); __v; ))
    #define readl(c)        (( u32 __v = readl_relaxed(c); __iormb(); __v; ))

    #define writeb(v, c)    (( __iowmb(); writeb_relaxed(v, c); ))
    #define writew(v, c)    (( __iowmb(); writew_relaxed(v, c); ))
    #define writel(v, c)    (( __iowmb(); writel_relaxed(v, c); ))
