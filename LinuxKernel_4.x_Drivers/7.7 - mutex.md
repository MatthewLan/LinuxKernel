# 互斥体
    <<Linux设备驱动开发详解：基于最新的Linux 4.0内核>>


##### 互斥体的操作
    1. 定义互斥体，并初始化
    struct mutex my_mutex;
    mutex_init(&my_mutext);

    2. 获取互斥体
    void mutex_lock(struct mutex *lock);
    int mutex_lock_interruptible(struct mutex *lock);
    int mutex_trylock(struct mutex *lock);

    mutex_lock()引起的睡眠不能被信号打断，而mutex_lock_interruptible()可以；

    3. 释放互斥体
    void mutex_unlock(struct mutex *lock);


    e.g.
    struct mutex my_mutex;
    mutex_init(&my_mutex);
    mutex_lock(&my_mutex);
    ...
    mutex_unlock(&my_mutex);


##### 互斥体与自旋锁的区别
    互斥体和自旋锁属于不同层次的互斥手段，前者的实现依赖于后者；
    在互斥体本身的实现上，为了保证互斥体结构存取的原子性，需要自旋锁来互斥；所以自旋锁属于更底层的手段；

    互斥体是进程级的，用于多个进程之间对资源的互斥，
    虽然也是在内核中，但是该内核执行路径是以进程的身份，代表进程来争夺资源的；

    如果竞争失败，会发生进程上下文切换，当前进程进入睡眠状态，CPU将运行其它进程；
    鉴于进程上下文切换的开销也很大，因此只有当进程占用资源较长时，用互斥体才是较好的选择；

    当所要保护的临界区访问时间比较短时，用自旋锁是非常方便的，因为它可节省上下文切换的时间；
    但是CPU得不到自旋锁会在那里空转直到其它执行单元解锁为止，所以不能在临界区里长时间停留，否则会降低系统的效率；


##### 自旋锁和互斥体选用的3项原则
    1. 当锁不能被获取到时，使用互斥体的开销时进程上下文切换时间，
       使用自旋锁的开销时等待获取自旋锁（由临界区执行时间决定）；
       若临界区比较小，宜使用自旋锁；若临界区很大，应使用互斥体；
    2. 互斥体所保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含这样代码的临界区；
       因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一个进程企图获取本自旋锁，死锁就会发生；
    3. 互斥体存在于进程上下文，因此如果被保护的共享资源需要在中断或软中断情况下使用，只能选择自旋锁；
       当然，如果一定要使用互斥体，则只能通过 mutex_trylock()方式进行，不能获取就立即返回以避免阻塞；
